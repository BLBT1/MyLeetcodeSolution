# 483. Smallest Good Base

## 可能吗？

要把一个数字转化成一个最低的进制，让那个进制的数字是digit全是1。这是有可能的。因为有n-1 进制兜底。 也就是说，任何一个数， 可以转化成 进制 b= n-1，在 b 进制里，n = 11

## 进制转化

把任何10进制数n 转化成别的进制k位数 n_ = d1d2d3...dk：

n = d1*b^0 + d2*b^1 + d3*b^2 ...dk*b^(k-1)

这里我们要每位都是1， 那

n = b^0+b^1...b^(k-1)

这是一个等比数列

## 等比数列求和公式

n = b^0+b^1...b^(k-1) = (b^k-1)/(b-1), 求和公式的推导可以在网上找到

对于等式 ```n = (b^k-1)/(b-1)``` 我们首先想想到是对于b进行二分搜索。 可是，(b-1)*n+1 = b^k, 我们想要k是个整数，这个等式没有给我们缩小搜索区间的指向， 所以只能暴力搜索。那就是 [3, 10^18-1] 的 b 的搜索范围 > 10^6, 肯定超时。

这样只能对 k 进行搜索，k 的范围是 log(1e18)/log(2), 是可行的，可以遍历所有的k

知道k了以后， 因为 n = (b^k-1)/(b-1) => (b-1)n+1 = b^k => b-n+1 = b^k是超越方程， 所以不能求解。 我们只能对b在进行二分。 这个时候我们 n = (b^k-1)/(b-1)是一个单调递增的方程， 所以确定k之后就可以用二分搜索了在找b了。```注意，我们一旦确定方程是递增的，而且知道怎么缩小搜索空间，就可以用二分搜索了```。但是还需要确定b的范围。 b的下限就是2 (2进制)， 上限的估计如下：

```
n = (b^k-1)/(b-1)
n(b-1)+1 = b^k
nb - n + 1 = b^k as n > 3, so n-1 > 0
nb-n > b^k, 
nb < b^k
n < b^k/ k
n < b^(k-1)
b < n^(1/(1-k)), 这样k的上限搜索范围就确定了
```

## 时间复杂度

O(K*log(B)), k是所有可能的数字的位数，所以是log(N), B <  n^(1/(1-k)) => B < n^(1/(1-logN))
