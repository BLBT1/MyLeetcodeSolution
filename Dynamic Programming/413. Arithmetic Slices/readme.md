# 413. Arithmetic Slices

```
[1,2,3,4,7]
 0 0 1 3 0
```

看上面的例子，[1,2,3] 有１个等差，[1,2,3,4] 有三个等差, 那我们最后答案如果求和，就会多出一个。　如果取 dp[n-1], 那答案是０，也是不对的。

这里很巧妙的思路是：定义 dp[i] 在这前数列加上 nums[i] 后　能产生的等差的增量。　看一个例子：

```
// [1,2,3,4,5,10, 11, 12, 13]
//      1 2 3          1   2
```

- [1,2]　有０个等差

- [1,2,3] 就多了一个等差，计１

- [1,2,3,4] 多了两个等差，计２

- [1,2,3,4,5]多了３个等差

所以我们发现规律，一个长度为ｋ的等差 nums[0:k]，如果增加一个nums[i],是得他出现了一个长度为k+1的等差，能他一定增加了k-3+1个等差：nums[0:k], nums[1:k], nums[2,k] ... nums[k-3,k]

所以此题的状态转移方程是:

```cpp
    if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2])
        dp[i] = dp[i-1]+1;
    else
        dp[i] = 0;
```

最后的结果就是dp求和
