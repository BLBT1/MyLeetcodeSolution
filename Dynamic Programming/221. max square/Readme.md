# 221. Maximal Square

这道题容易产生两个联想：

1. 想到 200，可能想用dfs和bfs，但是这种想法显然错误

2. 想到 84，85这两题，把他的每一列拍扁来做，此方法是可行的，但不是最优，且代码复杂


### 最常规做法
用一个二维dp， 首先我们思考他的dp[i][j]定义是什么， 既然是在一个m*n的矩阵里找， 那我们其实很快想到他的dp[i][j]表示右下角为(i,j)的```最大正方形边长```。如此就很容易发现这个是一个子问题。
接下来需要思考他的状态转移方程，作为一个二维dp，对于（i，j）点， 显然我们需要思考 dp[i][j-1], dp[i-1][j], dp[i][j-1] 这几个点。
具体的状态转移方程为此三点去最小：
```cpp
    if (matrix[i][j] == '1')
    {
        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
    }
```
假设matrix[i][j]==1，那么对于右下角为（i,j）的可能的最大正方形，主要取决于dp[i-1][j-1]有多大, 同时还要考虑第i行和第j列分别有多少1与（i,j）连着

最后注意，输出的面积是最长边长的平方。
